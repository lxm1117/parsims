/* ========================================================================
   pDE: Parallel version of Storn and Price's Differential evolution 
   applied to NEURON modeling

   c2005 Jose Ambros-Ingerson jose@kiubo.net
   
   $Id: eval_slave.c,v 1.51 2008/05/20 19:32:31 jose Exp $

   ======================================================================== */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <memory.h>
#include <sys/types.h>
#include <unistd.h>

#include <mpi.h>

#include "jLib.h"
#include "pDE.h"

/* ------------------------------------------------------------------------ */
void eval_slave( pRun *pRn )
{
  MPI_Status status;

  /* MPI_Recv( &D, 1, MPI_INT, 0, DTAG, MPI_COMM_WORLD, &status); */

  while( 1 ){
    MPI_Recv( pRn->Pop_buf, pRn->Pop_D, MPI_DOUBLE, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status);

    if (status.MPI_TAG == DIETAG) {
      return;
    }
    evaluateN( pRn ); 		       

    MPI_Send( pRn->Pop_buf, pRn->Pop_D, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);

    fflush( stdout );
  }

}

/* ================================================================================
  pDE's calling sequence is
    $ gnu_time -f "%e" -o Tid-eTime.txt nrniv -nogui main.hoc Tid-asg.hoc Tid-fit.hoc >> Tid-elog.txt 2>&1

    $ gnu_time -f "%e" -o time-exec.txt nrniv -nogui main.hoc asg.hoc fit.hoc >> logfile.txt 2>&1

  where 
  - Tid is TmpDir/pDE-Rank-pid where TmpDir is specified in the .pDE spec file and
        Rank and pid are determined by pDE 
  - gnu_time times the execution of nrniv and stores result in Tid-eTime.txt
  - main.hoc runs simulator. Writen by user and specified in pDE spec file. Interface with pDE defined below.
  - Tid-asg.hoc does the variable assignments as detailed in the Fit-parm values of the pDE spec file
  - Tid-fit.hoc executes each Fit-case and records values in file
  
  ---- main.hoc ----  // defined by user
  // main hoc must define
  begintemplate pDE_fit_case	// 
  ...
  endtemplate pDE_fit_case
  objref pDE_fc_list
  func pDE_do_fit_case(){ // return fit_value for pDE_fit_case i in pDE_fc_list
    i = $1
    ...
    return fit_value
  }
  proc dfc_plot_all(){	// to plot results for log-cbest.hoc log file
  }
  ---- Tid-asg.hoc ---- // Generated by pDE
  [VERBATIM section from pDE file]
  proc pDE_asg(){	// assignments as detailed in Fit-parm in pDE spec file
    parm_1 = val_1
    ...
  }

  ---- Tid-fit.hoc ---- // Generated by pDE
  objref pDE_outF 
  pDE_outF = new File() 
  pDE_outF.wopen( "/axon/d1/Users/jose/MyTemp/pDE-12-8041-res.txt" ) 

  objref pDE_eval 
  pDE_fc_list = new List() // must be defined (using objref) previously
  proc pDE_do_all(){ local i
    pDE_eval = new Vector() 
    for i=0, pDE_fc_list.count-1 pDE_eval.append( pDE_do_fit_case( i ))
    printf( "Error Sum %g\nDetail: ", pDE_eval.sum() )
    for i=0,pDE_eval.size-1 printf( " %10g", pDE_eval.x[i] )
    printf( "\n" )
  }
  
  pDE_fc_list.append( new pDE_fit_case( "p1_1", ..., "p10_1" )) // parameters defined in pDE spec file
  ...
  pDE_fc_list.append( new pDE_fit_case( "p1_k", ..., "p10_k" ))

  pDE_do_all()
  pDE_outF.printf( "%.10g\n", pDE_eval.sum() ) 
  pDE_eval.printf( pDE_outF )
  pDE_outF.close()
  ---- end-of-fit.hoc ----
  // dfc_plot_all() // called in log-cbest.hoc log file

  ------------------------------------------------------------------------------------------

   ErrNo	0	OK
   		-1	Cant write assignment file
   		-2	Cant write fit file	
   		1	Cant open results file
		2	Error reading results from file (sum)
		3	Error reading results from file (detail)
		4	Cant open timing results
		5	Error reading timing results

  -------------------------------------------------------------------------------- */
void evaluateN( pRun *pRn )
{
  static char	hoc_asg[128], hoc_fit[128], cmd[1024], elog[128], txt_res[128], eTimef[128], hoc_err[128];
  static int do_init=1;
  int i, ErrNo, sysR;
  FILE 	*fp;
  
  pRn->Pop_buf[pRn->P_errS]  = pRn->fCaseN * 1e50;	/* Default assigns in case of error */
  for( i=0; i < pRn->fCaseN; ++i ) 
    pRn->Pop_buf[pRn->P_errD+i] = 1e50;
  pRn->Pop_buf[pRn->P_etime]  = 0.0;

  ErrNo = 0;

  if( do_init ){
    do_init = 0;

    sprintf( hoc_asg, "%s/pDE-%d-%d-asg.hoc", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( hoc_fit, "%s/pDE-%d-%d-fit.hoc", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( hoc_err, "%s/pDE-%d-%d-err.hoc", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( txt_res, "%s/pDE-%d-%d-res.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( elog, "%s/pDE-%d-%d-elog.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( eTimef, "%s/pDE-%d-%d-eTimef.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    //sprintf( cmd, "my_time -f \"%%e\" -o %s nrniv -nogui %s %s %s >> %s 2>&1", 
	//     eTimef, pRn->hoc_main, hoc_asg, hoc_fit, elog ); 
    
    sprintf( cmd, "time -f \"%%e\" -o %s nrniv -nogui %s %s %s >> %s 2>&1", 
	     eTimef, pRn->hoc_main, hoc_asg, hoc_fit, elog ); 



    ErrNo = save_hoc_fit( hoc_fit, txt_res, pRn );
  }

  if( ErrNo==0 ) {
    int go_on=1, ntry=0;
    while( go_on ){
      /* if( ErrNo==0 ) ErrNo = do_hoc_asg( hoc_asg, pRn, pRn->Pop_buf ); */
      ErrNo = do_hoc_asg( hoc_asg, pRn, pRn->Pop_buf );
      if( ErrNo==0 ) sysR = system( cmd );

      if ( ErrNo==0 && (NULL == (fp = fopen( txt_res, "r" )))) {
	printf("\nERROR Cannot open results file >>%s<< sysR=%d\n", txt_res, sysR );
	ErrNo = 1;
      }
      if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[pRn->P_errS] ))){
	fprintf( stdout, "\n\n ERROR: reading results from file (sum) >>%s<< sysR=%d\n", txt_res, sysR );
	ErrNo = 2;
      }

      for( i=0; i < pRn->fCaseN; ++i ) 
	if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[pRn->P_errD+i] ))){
	  fprintf( stdout, "\n\n ERROR: reading results from file (detail) %s\n", txt_res );
	  ErrNo = 3;
	}
  
      if( ErrNo==0 || ErrNo==2 || ErrNo==3 ) fclose( fp );

      /* read elapsed time values */
      if ( ErrNo==0 && (NULL == (fp = fopen( eTimef, "r" )))) {
	printf("\nERROR Cannot open timing results file >>%s<<\n", eTimef );
	ErrNo = 4;
      }
      if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[ pRn->P_etime ] ))){
	fprintf( stdout, "\n\n ERROR: reading timing results file %s\n", eTimef );
	ErrNo = 5;
      }
      if( ErrNo==0 || ErrNo==5 ) fclose( fp );

      if( ErrNo==0 || ntry > 0 ) go_on=0;
      else ++ntry;
    }
  }
  if( ErrNo != 0 ) hoc_write_pop_buf( pRn, hoc_err, pRn->Pop_buf );

  pRn->Pop_buf[pRn->P_ESerrN]  = (double) ErrNo;

  if( ErrNo != 0 && pRn->abort_on_eval_error ){
    fprintf( stdout, "\n\n eval_slave ERROR %d; abort_on_eval_error=%d so doing exit(1)\n\n", 
	     ErrNo, pRn->abort_on_eval_error  );
    exit( 1 );
  }
}

void evaluateN_old( pRun *pRn )
{
  static char	hoc_asg[128], hoc_fit[128], cmd[256], elog[128], txt_res[128], eTimef[128];
  static int do_init=1;
  int i, ErrNo, sysR;
  FILE 	*fp;
  
  pRn->Pop_buf[pRn->P_errS]  = pRn->fCaseN * 1e50;	/* Default assigns in case of error */
  for( i=0; i < pRn->fCaseN; ++i ) 
    pRn->Pop_buf[pRn->P_errD+i] = 1e50;
  pRn->Pop_buf[pRn->P_etime]  = 0.0;

  ErrNo = 0;

  if( do_init ){
    do_init = 0;

    sprintf( hoc_asg, "%s/pDE-%d-%d-asg.hoc", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( hoc_fit, "%s/pDE-%d-%d-fit.hoc", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( txt_res, "%s/pDE-%d-%d-res.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( elog, "%s/pDE-%d-%d-elog.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    sprintf( eTimef, "%s/pDE-%d-%d-eTimef.txt", pRn->tmp_dir, pRn->rank, pRn->pid );
    //sprintf( cmd, "my_time -f \"%%e\" -o %s nrniv %s %s %s >> %s 2>&1", 
	//     eTimef, pRn->hoc_main, hoc_asg, hoc_fit, elog );

    sprintf( cmd, "time -f \"%%e\" -o %s nrniv %s %s %s >> %s 2>&1", 
	     eTimef, pRn->hoc_main, hoc_asg, hoc_fit, elog );

    ErrNo = save_hoc_fit( hoc_fit, txt_res, pRn );
  }

  if( ErrNo==0 ) ErrNo = do_hoc_asg( hoc_asg, pRn, pRn->Pop_buf );
  if( ErrNo==0 ) sysR = system( cmd );

  if ( ErrNo==0 && (NULL == (fp = fopen( txt_res, "r" )))) {
    printf("\nERROR Cannot open results file >>%s<< sysR=%d\n", txt_res, sysR );
    ErrNo = 1;
  }
  if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[pRn->P_errS] ))){
    fprintf( stdout, "\n\n ERROR: reading results from file (sum) >>%s<< sysR=%d\n", txt_res, sysR );
    ErrNo = 2;
  }

  for( i=0; i < pRn->fCaseN; ++i ) 
    if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[pRn->P_errD+i] ))){
      fprintf( stdout, "\n\n ERROR: reading results from file (detail) %s\n", txt_res );
      ErrNo = 3;
    }
  
  if( ErrNo==0 || ErrNo==2 || ErrNo==3 ) fclose( fp );

  /* read elapsed time values */
  if ( ErrNo==0 && (NULL == (fp = fopen( eTimef, "r" )))) {
    printf("\nERROR Cannot open timing results file >>%s<<\n", eTimef );
    ErrNo = 4;
  }
  if( ErrNo==0 && (1 != fscanf( fp, "%lf", &pRn->Pop_buf[ pRn->P_etime ] ))){
    fprintf( stdout, "\n\n ERROR: reading timing results file %s\n", eTimef );
    ErrNo = 5;
  }
  if( ErrNo==0 || ErrNo==5 ) fclose( fp );

  pRn->Pop_buf[pRn->P_ESerrN]  = (double) ErrNo;

}

/* ------------------------------------------------------------------------ */
int write_hoc_asg( FILE *fp, pRun *pRn, double val[] )
{
  int i;

  fprintf( fp, "//----- pDE VERBATIM -----\n%s\n//----- ENDVERBATIM-----\n\n", pRn->hoc_verbatim );

  fprintf( fp, "strdef  pDE_log_name\n" );
  fprintf( fp, "proc pDE_asg(){\n  // hoc pDE gen variables\n" );
  fprintf( fp, "  pDE_log_name = \"%s\"\n", pRn->log_name );
  fprintf( fp, "  pDE_gen_N = %d\n", pRn->gen_N );
  fprintf( fp, "  pDE_Pop_ibest = %d\n", pRn->Pop_ibest );

  fprintf( fp, "  // hoc set variables\n" );
  for( i=0; i<pRn->sParN; ++i )
    fprintf( fp, "  %s = %.10g\n", pRn->sPar[i]->name, pRn->sPar[i]->init );

  fprintf( fp, "  // hoc fit variables\n" );
  for( i=0; i<pRn->D; ++i ){
    fprintf( fp, "  %s = %.10g\n", pRn->fPar[i]->name, val[i] );
  }
  fprintf( fp, "}\n" );

  fprintf( fp, "// log pDE nfeval\n" );
  fprintf( fp, "{ printf( \"nfeval %%g\\n\", %g ) }\n", val[pRn->P_nfeval] );

  return( 0 );
}
/* ------------------------------------------------------------------------ */
int do_hoc_asg( char *fname, pRun *pRn, double val[] )
{
  int rv;
  FILE *fp;

  if ( NULL == (fp = fopen( fname, "w" ))) {
    printf("\nERROR Cannot write assignment file >>%s<<\n", fname );
    return( -1 );
  }
  rv = write_hoc_asg( fp, pRn, val );

  fclose( fp );
  return( rv );
}

/* ------------------------------------------------------------------------ */
int save_hoc_fit( char *fname, char *txt_res, pRun *pRn )
{
  FILE	*fp;
  if ( NULL == (fp = fopen( fname, "w" ))) {
    printf("\nERROR Cannot write fit file >>%s<<\n", fname );
    return( -2 );
  }
  fprintf( fp, "objref pDE_outF \n" );
  fprintf( fp, "pDE_outF = new File() \n" );
  fprintf( fp, "pDE_outF.wopen( \"%s\" ) \n", txt_res );

  write_eval_hoc( fp, pRn );

  fprintf( fp, "\npDE_outF.printf( \"%%.10g\\n\", pDE_eval.sum() ) \n" );
  fprintf( fp, "pDE_eval.printf( pDE_outF )\n" );
  fprintf( fp, "pDE_outF.close()\n" );

  fclose( fp );
  return( 0 );
}

/* ------------------------------------------------------------------------ */
void write_eval_hoc( FILE *fp, pRun *pRn )
{
  int	icase;
  FitCase *aP;

  fprintf( fp, "\n\
// ---------- begin write_eval_hoc ----------\n\
objref pDE_eval \n\
pDE_fc_list = new List() // must be defined (using objref) previously\n\
\n\
proc pDE_do_all(){ local i\n\
  pDE_eval = new Vector() \n\
  for i=0, pDE_fc_list.count-1 pDE_eval.append( pDE_do_fit_case( i ))\n\
\n\
  printf( \"Error Sum %%g\\nDetail: \", pDE_eval.sum() )\n\
  for i=0,pDE_eval.size-1 printf( \" %%10g\", pDE_eval.x[i] )\n\
  printf( \"\\n\" )\n\
}\n\
\n" );

  for( icase=0; icase<pRn->fCaseN; ++icase ){
    aP = pRn->fCase[icase];
    fprintf( fp, "pDE_fc_list.append( new pDE_fit_case( \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\" ))\n\n", 
	     aP->name, aP->template, aP->func, aP->scale, 
	     aP->hoc_var, aP->hoc_before, aP->hoc_after, 
	     aP->tgt_files, aP->tgt_before, aP->tgt_after );
  }

  fprintf( fp, "pDE_do_all()\n// ---------- end write_eval_hoc ----------\n\n" );
}

